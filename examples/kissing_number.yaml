task_id: "kissing_number_problem"
task_description: |
  Evolve a Python function to find or improve the kissing number for a given dimension.
  The kissing number problem asks: In n-dimensional Euclidean space, what is the maximum number
  of non-overlapping unit spheres that can be arranged such that they all touch (are tangent to)
  a central unit sphere?
  
  The function should take the dimension n as input and return:
  1. The maximum number of spheres that can be arranged (kissing number)
  2. A list of sphere centers (each center is a tuple of n coordinates)
  3. A boolean indicating if the arrangement is valid (all spheres touch the center and don't overlap)
  
  Constraints:
  1. All sphere centers must be at distance exactly 2.0 from the origin (since unit spheres
     with centers at distance 2.0 will be tangent to the unit sphere at the origin).
     For a center c = (c1, c2, ..., cn), we need: sqrt(c1^2 + c2^2 + ... + cn^2) = 2.0
  2. No two spheres should overlap. The distance between any two centers must be >= 2.0.
     For centers c1 and c2: sqrt(sum((c1[i] - c2[i])^2 for i in range(n))) >= 2.0
  3. The function should aim to maximize the number of spheres while satisfying constraints.
  
  Known kissing numbers:
  - 1D: 2
  - 2D: 6
  - 3D: 12
  - 4D: 24
  - 8D: 240
  - 24D: 196560

function_name: "find_kissing_number"
allowed_imports: ["math", "random", "numpy", "itertools"]

tests:
  - description: "Kissing number for 1D (should be 2)"
    name: "dimension_1_test"
    test_cases:
      - input: [1]
        validation_func: |
          def validate(output):
              if not isinstance(output, tuple) or len(output) != 3:
                  return "Output should be a tuple: (kissing_number, centers_list, is_valid)"
              
              kissing_num, centers, is_valid = output
              
              if not isinstance(kissing_num, int):
                  return "First element (kissing_number) should be an integer."
              if not isinstance(centers, list):
                  return "Second element (centers) should be a list."
              if not isinstance(is_valid, bool):
                  return "Third element (is_valid) should be a boolean."
              
              # For 1D, known kissing number is 2
              if kissing_num < 2:
                  return f"For dimension 1, kissing number should be at least 2, got {kissing_num}"
              
              if len(centers) != kissing_num:
                  return f"Number of centers ({len(centers)}) should match kissing_number ({kissing_num})"
              
              if not is_valid:
                  return "The arrangement should be valid"
              
              # Check all centers are at distance 2.0 from origin
              for i, center in enumerate(centers):
                  if not isinstance(center, (tuple, list)) or len(center) != 1:
                      return f"Center {i} should be a tuple/list of length 1"
                  dist = abs(center[0])
                  if abs(dist - 2.0) > 1e-6:
                      return f"Center {i} ({center}) is not at distance 2.0 from origin (distance: {dist})"
              
              # Check no overlaps (distance between centers >= 2.0)
              for i in range(len(centers)):
                  for j in range(i + 1, len(centers)):
                      dist = abs(centers[i][0] - centers[j][0])
                      if dist < 2.0 - 1e-6:
                          return f"Centers {i} and {j} are too close (distance: {dist})"
              
              return True

  - description: "Kissing number for 2D (should be 6)"
    name: "dimension_2_test"
    test_cases:
      - input: [2]
        validation_func: |
          import math
          def validate(output):
              if not isinstance(output, tuple) or len(output) != 3:
                  return "Output should be a tuple: (kissing_number, centers_list, is_valid)"
              
              kissing_num, centers, is_valid = output
              
              if not isinstance(kissing_num, int):
                  return "First element (kissing_number) should be an integer."
              if not isinstance(centers, list):
                  return "Second element (centers) should be a list."
              if not isinstance(is_valid, bool):
                  return "Third element (is_valid) should be a boolean."
              
              # For 2D, known kissing number is 6
              if kissing_num < 6:
                  return f"For dimension 2, kissing number should be at least 6, got {kissing_num}"
              
              if len(centers) != kissing_num:
                  return f"Number of centers ({len(centers)}) should match kissing_number ({kissing_num})"
              
              if not is_valid:
                  return "The arrangement should be valid"
              
              # Check all centers are at distance 2.0 from origin
              for i, center in enumerate(centers):
                  if not isinstance(center, (tuple, list)) or len(center) != 2:
                      return f"Center {i} should be a tuple/list of length 2"
                  dist_sq = sum(c**2 for c in center)
                  dist = math.sqrt(dist_sq)
                  if abs(dist - 2.0) > 1e-6:
                      return f"Center {i} ({center}) is not at distance 2.0 from origin (distance: {dist})"
              
              # Check no overlaps (distance between centers >= 2.0)
              for i in range(len(centers)):
                  for j in range(i + 1, len(centers)):
                      dist_sq = sum((centers[i][k] - centers[j][k])**2 for k in range(2))
                      dist = math.sqrt(dist_sq)
                      if dist < 2.0 - 1e-6:
                          return f"Centers {i} and {j} are too close (distance: {dist})"
              
              return True

  - description: "Kissing number for 3D (should be 12)"
    name: "dimension_3_test"
    test_cases:
      - input: [3]
        validation_func: |
          import math
          def validate(output):
              if not isinstance(output, tuple) or len(output) != 3:
                  return "Output should be a tuple: (kissing_number, centers_list, is_valid)"
              
              kissing_num, centers, is_valid = output
              
              if not isinstance(kissing_num, int):
                  return "First element (kissing_number) should be an integer."
              if not isinstance(centers, list):
                  return "Second element (centers) should be a list."
              if not isinstance(is_valid, bool):
                  return "Third element (is_valid) should be a boolean."
              
              # For 3D, known kissing number is 12
              if kissing_num < 12:
                  return f"For dimension 3, kissing number should be at least 12, got {kissing_num}"
              
              if len(centers) != kissing_num:
                  return f"Number of centers ({len(centers)}) should match kissing_number ({kissing_num})"
              
              if not is_valid:
                  return "The arrangement should be valid"
              
              # Check all centers are at distance 2.0 from origin
              for i, center in enumerate(centers):
                  if not isinstance(center, (tuple, list)) or len(center) != 3:
                      return f"Center {i} should be a tuple/list of length 3"
                  dist_sq = sum(c**2 for c in center)
                  dist = math.sqrt(dist_sq)
                  if abs(dist - 2.0) > 1e-6:
                      return f"Center {i} ({center}) is not at distance 2.0 from origin (distance: {dist})"
              
              # Check no overlaps (distance between centers >= 2.0)
              for i in range(len(centers)):
                  for j in range(i + 1, len(centers)):
                      dist_sq = sum((centers[i][k] - centers[j][k])**2 for k in range(3))
                      dist = math.sqrt(dist_sq)
                      if dist < 2.0 - 1e-6:
                          return f"Centers {i} and {j} are too close (distance: {dist})"
              
              return True

  - description: "General dimension test (should find valid arrangement)"
    name: "general_dimension_test"
    test_cases:
      - input: [4]
        validation_func: |
          import math
          def validate(output):
              if not isinstance(output, tuple) or len(output) != 3:
                  return "Output should be a tuple: (kissing_number, centers_list, is_valid)"
              
              kissing_num, centers, is_valid = output
              
              if not isinstance(kissing_num, int) or kissing_num < 1:
                  return "First element (kissing_number) should be a positive integer."
              if not isinstance(centers, list):
                  return "Second element (centers) should be a list."
              if not isinstance(is_valid, bool):
                  return "Third element (is_valid) should be a boolean."
              
              if len(centers) != kissing_num:
                  return f"Number of centers ({len(centers)}) should match kissing_number ({kissing_num})"
              
              if not is_valid:
                  return "The arrangement should be valid"
              
              dimension = 4
              
              # Check all centers are at distance 2.0 from origin
              for i, center in enumerate(centers):
                  if not isinstance(center, (tuple, list)) or len(center) != dimension:
                      return f"Center {i} should be a tuple/list of length {dimension}"
                  dist_sq = sum(c**2 for c in center)
                  dist = math.sqrt(dist_sq)
                  if abs(dist - 2.0) > 1e-6:
                      return f"Center {i} ({center}) is not at distance 2.0 from origin (distance: {dist})"
              
              # Check no overlaps (distance between centers >= 2.0)
              for i in range(len(centers)):
                  for j in range(i + 1, len(centers)):
                      dist_sq = sum((centers[i][k] - centers[j][k])**2 for k in range(dimension))
                      dist = math.sqrt(dist_sq)
                      if dist < 2.0 - 1e-6:
                          return f"Centers {i} and {j} are too close (distance: {dist})"
              
              # For 4D, known kissing number is 24, but we accept any valid arrangement
              return True

